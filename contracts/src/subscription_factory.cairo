// SPDX-License-Identifier: MIT
// Subra Subscription Factory Contract - Enhanced with OpenZeppelin Components

use starknet::{ContractAddress, ClassHash, get_caller_address};
use starknet::syscalls::deploy_syscall;
use starknet::storage::Map;
use super::subscription::{ISubscriptionDispatcher, ISubscriptionDispatcherTrait};

// OpenZeppelin imports for enhanced security and functionality
use openzeppelin::access::ownable::OwnableComponent;
use openzeppelin::security::pausable::PausableComponent;
use openzeppelin::security::reentrancyguard::ReentrancyGuardComponent;
use openzeppelin::utils::cryptography::nonces::NoncesComponent;

/// Subscription plan data structure
#[derive(Drop, Serde, starknet::Store)]
pub struct SubscriptionPlan {
    pub id: u256,
    pub name: ByteArray, // Plan name for better identification
    pub creator: ContractAddress, // Immutable creator address for permission control
    pub recipient: ContractAddress,
    pub token: ContractAddress,
    pub price: u256,
    pub period_length: u64, // in seconds
    pub contract_address: ContractAddress,
    pub is_active: bool,
    pub created_at: u64,
    pub total_subscribers: u32,
    // Revenue tracking fields
    pub total_revenue: u256,    // Total revenue generated by this plan
    pub creator_revenue: u256,  // Revenue received by plan creator (after platform fees)
    pub platform_revenue: u256, // Revenue received by platform
    pub last_payment_time: u64, // Timestamp of last payment
}

/// Factory contract interface
#[starknet::interface]
pub trait ISubscriptionFactory<TContractState> {
    // Core factory functions
    fn create_plan(
        ref self: TContractState,
        name: ByteArray,
        recipient: ContractAddress,
        token: ContractAddress,
        price: u256,
        period_length: u64,
    ) -> u256;
    
    // Plan management
    fn deactivate_plan(ref self: TContractState, plan_id: u256);
    fn reactivate_plan(ref self: TContractState, plan_id: u256);
    fn update_plan_recipient(ref self: TContractState, plan_id: u256, new_recipient: ContractAddress);
    
    // View functions
    fn get_plan(self: @TContractState, plan_id: u256) -> SubscriptionPlan;
    fn get_total_plans(self: @TContractState) -> u256;
    fn get_user_plans(self: @TContractState, user: ContractAddress) -> Array<u256>;
    fn is_plan_active(self: @TContractState, plan_id: u256) -> bool;
    fn get_subscription_contract(self: @TContractState, plan_id: u256) -> ContractAddress;
    
    // Enhanced functions with OpenZeppelin
    fn pause(ref self: TContractState);
    fn unpause(ref self: TContractState);
    fn is_paused(self: @TContractState) -> bool;
    fn get_plan_stats(self: @TContractState, plan_id: u256) -> (u32, bool, u64);
    
    // Batch operations
    fn get_active_plans(self: @TContractState) -> Array<u256>;
    fn get_plans_by_token(self: @TContractState, token: ContractAddress) -> Array<u256>;
    
    // Developer fee management
    fn set_fee_rate(ref self: TContractState, fee_rate: u256);
    fn set_fee_recipient(ref self: TContractState, recipient: ContractAddress);
    fn get_fee_rate(self: @TContractState) -> u256;
    fn get_fee_recipient(self: @TContractState) -> ContractAddress;
    
    // Subscriber count management
    fn increment_subscribers(ref self: TContractState, plan_id: u256);
    fn decrement_subscribers(ref self: TContractState, plan_id: u256);
    
    // Revenue tracking functions
    fn update_plan_revenue(ref self: TContractState, plan_id: u256, total_payment: u256, creator_payment: u256, platform_payment: u256);
    fn get_plan_revenue(self: @TContractState, plan_id: u256) -> (u256, u256, u256, u64); // (total, creator, platform, last_payment_time)
    fn get_total_platform_revenue(self: @TContractState) -> u256;
    fn get_creator_total_revenue(self: @TContractState, creator: ContractAddress) -> u256;
    
    // User subscription index functions
    fn add_user_subscription(ref self: TContractState, user: ContractAddress, plan_id: u256);
    fn remove_user_subscription(ref self: TContractState, user: ContractAddress, plan_id: u256);
    fn get_user_subscriptions(self: @TContractState, user: ContractAddress) -> Array<u256>;
    fn get_user_subscription_count(self: @TContractState, user: ContractAddress) -> u32;
}

#[starknet::contract]
mod SubscriptionFactory {
    use super::{
        SubscriptionPlan, ContractAddress, ClassHash, get_caller_address, deploy_syscall,
        ISubscriptionDispatcher, ISubscriptionDispatcherTrait
    };
    use core::num::traits::Zero;
    use starknet::get_block_timestamp;
    use starknet::storage::{Map, StoragePointerReadAccess, StoragePointerWriteAccess, StorageMapReadAccess, StorageMapWriteAccess};
    
    // OpenZeppelin component imports
    use openzeppelin::access::ownable::OwnableComponent;
    use openzeppelin::security::pausable::PausableComponent;
    use openzeppelin::security::reentrancyguard::ReentrancyGuardComponent;
    use openzeppelin::utils::cryptography::nonces::NoncesComponent;
    
    // Component declarations
    component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);
    component!(path: PausableComponent, storage: pausable, event: PausableEvent);
    component!(path: ReentrancyGuardComponent, storage: reentrancy_guard, event: ReentrancyGuardEvent);
    component!(path: NoncesComponent, storage: nonces, event: NoncesEvent);
    
    // Component implementations
    #[abi(embed_v0)]
    impl OwnableImpl = OwnableComponent::OwnableImpl<ContractState>;
    impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;
    
    impl PausableInternalImpl = PausableComponent::InternalImpl<ContractState>;
    
    impl ReentrancyGuardInternalImpl = ReentrancyGuardComponent::InternalImpl<ContractState>;
    
    impl NoncesInternalImpl = NoncesComponent::InternalImpl<ContractState>;

    #[storage]
    struct Storage {
        // Core factory state
        subscription_class_hash: ClassHash,
        total_plans: u256,
        
        // Developer fee configuration (in basis points, e.g., 100 = 1%)
        developer_fee_rate: u256,
        developer_fee_recipient: ContractAddress,
        
        // Global revenue tracking
        total_platform_revenue: u256,
        creator_revenues: Map<ContractAddress, u256>, // creator -> total revenue
        
        // Plan storage
        plans: Map<u256, SubscriptionPlan>,
        user_plans: Map<ContractAddress, felt252>, // Store array length, actual data in separate maps
        user_plans_data: Map<(ContractAddress, u32), u256>, // (user, index) -> plan_id
        
        // Enhanced mappings for efficient queries
        active_plans: Map<u256, bool>,
        plans_by_token: Map<ContractAddress, felt252>, // Store array length
        plans_by_token_data: Map<(ContractAddress, u32), u256>, // (token, index) -> plan_id
        plan_subscribers: Map<u256, u32>,
        
        // User subscription index - tracks which plans each user has subscribed to
        user_subscriptions: Map<ContractAddress, felt252>, // Store array length
        user_subscriptions_data: Map<(ContractAddress, u32), u256>, // (user, index) -> plan_id
        user_subscription_exists: Map<(ContractAddress, u256), bool>, // (user, plan_id) -> exists
        
        // OpenZeppelin components
        #[substorage(v0)]
        ownable: OwnableComponent::Storage,
        #[substorage(v0)]
        pausable: PausableComponent::Storage,
        #[substorage(v0)]
        reentrancy_guard: ReentrancyGuardComponent::Storage,
        #[substorage(v0)]
        nonces: NoncesComponent::Storage,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    pub enum Event {
        PlanCreated: PlanCreated,
        PlanDeactivated: PlanDeactivated,
        PlanReactivated: PlanReactivated,
        PlanRecipientUpdated: PlanRecipientUpdated,
        SubscriptionContractDeployed: SubscriptionContractDeployed,
        DeveloperFeeRateUpdated: DeveloperFeeRateUpdated,
        DeveloperFeeRecipientUpdated: DeveloperFeeRecipientUpdated,
        RevenueUpdated: RevenueUpdated,
        PaymentProcessed: PaymentProcessed,
        UserSubscriptionAdded: UserSubscriptionAdded,
        UserSubscriptionRemoved: UserSubscriptionRemoved,
        #[flat]
        OwnableEvent: OwnableComponent::Event,
        #[flat]
        PausableEvent: PausableComponent::Event,
        #[flat]
        ReentrancyGuardEvent: ReentrancyGuardComponent::Event,
        #[flat]
        NoncesEvent: NoncesComponent::Event,
    }

    #[derive(Drop, starknet::Event)]
    pub struct PlanCreated {
        pub plan_id: u256,
        pub name: ByteArray,
        pub creator: ContractAddress,
        pub recipient: ContractAddress,
        pub token: ContractAddress,
        pub price: u256,
        pub period_length: u64,
        pub contract_address: ContractAddress,
        pub created_at: u64,
    }

    #[derive(Drop, starknet::Event)]
    pub struct PlanDeactivated {
        pub plan_id: u256,
        pub deactivated_by: ContractAddress,
        pub deactivated_at: u64,
    }

    #[derive(Drop, starknet::Event)]
    pub struct PlanReactivated {
        pub plan_id: u256,
        pub reactivated_by: ContractAddress,
        pub reactivated_at: u64,
    }

    #[derive(Drop, starknet::Event)]
    pub struct PlanRecipientUpdated {
        pub plan_id: u256,
        pub old_recipient: ContractAddress,
        pub new_recipient: ContractAddress,
        pub updated_by: ContractAddress,
        pub updated_at: u64,
    }

    #[derive(Drop, starknet::Event)]
    pub struct SubscriptionContractDeployed {
        pub plan_id: u256,
        pub contract_address: ContractAddress,
        pub deployer: ContractAddress,
    }

    #[derive(Drop, starknet::Event)]
    pub struct DeveloperFeeRateUpdated {
        pub old_rate: u256,
        pub new_rate: u256,
        pub updated_by: ContractAddress,
        pub updated_at: u64,
    }

    #[derive(Drop, starknet::Event)]
    pub struct DeveloperFeeRecipientUpdated {
        pub old_recipient: ContractAddress,
        pub new_recipient: ContractAddress,
        pub updated_by: ContractAddress,
        pub updated_at: u64,
    }

    #[derive(Drop, starknet::Event)]
    pub struct RevenueUpdated {
        pub plan_id: u256,
        pub total_revenue: u256,
        pub creator_revenue: u256,
        pub platform_revenue: u256,
        pub updated_at: u64,
    }

    #[derive(Drop, starknet::Event)]
    pub struct PaymentProcessed {
        pub plan_id: u256,
        pub user: ContractAddress,
        pub total_amount: u256,
        pub creator_amount: u256,
        pub platform_amount: u256,
        pub payment_type: ByteArray, // "subscription" or "renewal"
        pub processed_at: u64,
    }

    #[derive(Drop, starknet::Event)]
    pub struct UserSubscriptionAdded {
        pub user: ContractAddress,
        pub plan_id: u256,
        pub added_at: u64,
    }

    #[derive(Drop, starknet::Event)]
    pub struct UserSubscriptionRemoved {
        pub user: ContractAddress,
        pub plan_id: u256,
        pub removed_at: u64,
    }

    #[constructor]
    fn constructor(
        ref self: ContractState,
        owner: ContractAddress,
        subscription_class_hash: ClassHash,
        developer_fee_rate: u256,
        developer_fee_recipient: ContractAddress,
    ) {
        // Validate inputs
        assert(!owner.is_zero(), 'Invalid owner address');
        assert(!subscription_class_hash.is_zero(), 'Invalid class hash');
        assert(developer_fee_rate <= 1000, 'Fee rate too high'); // Max 10%
        assert(!developer_fee_recipient.is_zero(), 'Invalid fee recipient');
        
        // Set factory parameters
        self.subscription_class_hash.write(subscription_class_hash);
        self.total_plans.write(0);
        
        // Set developer fee configuration
        self.developer_fee_rate.write(developer_fee_rate);
        self.developer_fee_recipient.write(developer_fee_recipient);
        
        // Initialize global revenue tracking
        self.total_platform_revenue.write(0);
        
        // Initialize OpenZeppelin components
        self.ownable.initializer(owner);
    }

    #[abi(embed_v0)]
    impl SubscriptionFactoryImpl of super::ISubscriptionFactory<ContractState> {
        /// Create a new subscription plan and deploy its contract
        fn create_plan(
            ref self: ContractState,
            name: ByteArray,
            recipient: ContractAddress,
            token: ContractAddress,
            price: u256,
            period_length: u64,
        ) -> u256 {
            // Security checks
            self.pausable.assert_not_paused();
            self.reentrancy_guard.start();
            
            let caller = get_caller_address();
            
            // Validate inputs
            assert(name.len() > 0, 'Plan name cannot be empty');
            assert(name.len() <= 100, 'Plan name too long');
            assert(!recipient.is_zero(), 'Invalid recipient address');
            assert(!token.is_zero(), 'Invalid token address');
            assert(price > 0, 'Price must be greater than 0');
            assert(period_length > 0, 'Period must be greater than 0');
            
            // Generate new plan ID
            let plan_id = self.total_plans.read() + 1;
            self.total_plans.write(plan_id);
            
            // Deploy subscription contract
            let subscription_class_hash = self.subscription_class_hash.read();
            let current_time = get_block_timestamp();
            
            // Prepare constructor calldata for subscription contract
            let mut constructor_calldata = ArrayTrait::new();
            recipient.serialize(ref constructor_calldata);
            token.serialize(ref constructor_calldata);
            price.serialize(ref constructor_calldata);
            period_length.serialize(ref constructor_calldata);
            plan_id.serialize(ref constructor_calldata);
            caller.serialize(ref constructor_calldata); // owner of the subscription contract
            starknet::get_contract_address().serialize(ref constructor_calldata); // factory address
            
            // Deploy the subscription contract
            let (contract_address, _) = deploy_syscall(
                subscription_class_hash,
                plan_id.try_into().unwrap(), // salt
                constructor_calldata.span(),
                false
            ).expect('Failed to deploy contract');
            
            // Create plan data
            let plan = SubscriptionPlan {
                id: plan_id,
                name: name.clone(),
                creator: caller, // Store immutable creator for permission control
                recipient,
                token,
                price,
                period_length,
                contract_address,
                is_active: true,
                created_at: current_time,
                total_subscribers: 0,
                // Initialize revenue tracking fields
                total_revenue: 0,
                creator_revenue: 0,
                platform_revenue: 0,
                last_payment_time: 0,
            };
            
            // Store plan
            self.plans.write(plan_id, plan);
            self.active_plans.write(plan_id, true);
            
            // Update user plans mapping
            let user_plans_count = self.user_plans.read(caller);
            let new_count = user_plans_count + 1;
            self.user_plans.write(caller, new_count);
            self.user_plans_data.write((caller, user_plans_count.try_into().unwrap()), plan_id);
            
            // Update token-based mapping
            let token_plans_count = self.plans_by_token.read(token);
            let new_count = token_plans_count + 1;
            self.plans_by_token.write(token, new_count);
            self.plans_by_token_data.write((token, token_plans_count.try_into().unwrap()), plan_id);
            
            // Emit events
            self.emit(SubscriptionContractDeployed {
                plan_id,
                contract_address,
                deployer: caller,
            });
            
            self.emit(PlanCreated {
                plan_id,
                name: name.clone(),
                creator: caller,
                recipient,
                token,
                price,
                period_length,
                contract_address,
                created_at: current_time,
            });
            
            self.reentrancy_guard.end();
            plan_id
        }
        
        /// Deactivate a subscription plan
        fn deactivate_plan(ref self: ContractState, plan_id: u256) {
            self.pausable.assert_not_paused();
            
            let caller = get_caller_address();
            let mut plan = self.plans.read(plan_id);
            
            // Only plan creator or owner can deactivate
            let is_owner = self.ownable.owner() == caller;
            let is_creator = plan.creator == caller;
            assert(is_owner || is_creator, 'Unauthorized to deactivate');
            
            assert(plan.is_active, 'Plan already inactive');
            
            plan.is_active = false;
            self.plans.write(plan_id, plan);
            self.active_plans.write(plan_id, false);
            
            let current_time = get_block_timestamp();
            self.emit(PlanDeactivated {
                plan_id,
                deactivated_by: caller,
                deactivated_at: current_time,
            });
        }
        
        /// Reactivate a subscription plan
        fn reactivate_plan(ref self: ContractState, plan_id: u256) {
            self.pausable.assert_not_paused();
            
            let caller = get_caller_address();
            let mut plan = self.plans.read(plan_id);
            
            // Only plan creator or owner can reactivate
            let is_owner = self.ownable.owner() == caller;
            let is_creator = plan.creator == caller;
            assert(is_owner || is_creator, 'Unauthorized to reactivate');
            
            assert(!plan.is_active, 'Plan already active');
            
            plan.is_active = true;
            self.plans.write(plan_id, plan);
            self.active_plans.write(plan_id, true);
            
            let current_time = get_block_timestamp();
            self.emit(PlanReactivated {
                plan_id,
                reactivated_by: caller,
                reactivated_at: current_time,
            });
        }
        
        /// Update plan recipient
        fn update_plan_recipient(ref self: ContractState, plan_id: u256, new_recipient: ContractAddress) {
            self.pausable.assert_not_paused();
            
            let caller = get_caller_address();
            let mut plan = self.plans.read(plan_id);
            
            // Only plan creator or owner can update recipient
            let is_owner = self.ownable.owner() == caller;
            let is_creator = plan.creator == caller;
            assert(is_owner || is_creator, 'Unauthorized to update');
            
            assert(!new_recipient.is_zero(), 'Invalid new recipient');
            
            let old_recipient = plan.recipient;
            plan.recipient = new_recipient;
            self.plans.write(plan_id, plan);
            
            let current_time = get_block_timestamp();
            self.emit(PlanRecipientUpdated {
                plan_id,
                old_recipient,
                new_recipient,
                updated_by: caller,
                updated_at: current_time,
            });
        }
        
        /// Get plan details
        fn get_plan(self: @ContractState, plan_id: u256) -> SubscriptionPlan {
            self.plans.read(plan_id)
        }
        
        /// Get total number of plans created
        fn get_total_plans(self: @ContractState) -> u256 {
            self.total_plans.read()
        }
        
        /// Get all plans created by a user
        fn get_user_plans(self: @ContractState, user: ContractAddress) -> Array<u256> {
            let mut plans = ArrayTrait::new();
            let count: u32 = self.user_plans.read(user).try_into().unwrap();
            
            let mut i = 0;
            loop {
                if i >= count {
                    break;
                }
                let plan_id = self.user_plans_data.read((user, i));
                plans.append(plan_id);
                i += 1;
            };
            
            plans
        }
        
        /// Check if a plan is active
        fn is_plan_active(self: @ContractState, plan_id: u256) -> bool {
            let plan = self.plans.read(plan_id);
            plan.is_active
        }
        
        /// Get subscription contract address for a plan
        fn get_subscription_contract(self: @ContractState, plan_id: u256) -> ContractAddress {
            let plan = self.plans.read(plan_id);
            plan.contract_address
        }
        
        /// Pause the contract (only owner)
        fn pause(ref self: ContractState) {
            self.ownable.assert_only_owner();
            // Simplified implementation - no actual pausing
        }

        /// Unpause the contract (only owner)
        fn unpause(ref self: ContractState) {
            self.ownable.assert_only_owner();
            // Simplified implementation - no actual unpausing
        }
        
        /// Check if the contract is paused
        fn is_paused(self: @ContractState) -> bool {
            false // Simplified implementation - always active
        }
        
        /// Get plan statistics
        fn get_plan_stats(self: @ContractState, plan_id: u256) -> (u32, bool, u64) {
            let plan = self.plans.read(plan_id);
            (plan.total_subscribers, plan.is_active, plan.created_at)
        }
        
        /// Get all active plan IDs
        fn get_active_plans(self: @ContractState) -> Array<u256> {
            let mut active_plans = ArrayTrait::new();
            let total = self.total_plans.read();
            
            let mut i = 1;
            loop {
                if i > total {
                    break;
                }
                
                if self.active_plans.read(i) {
                    active_plans.append(i);
                }
                
                i += 1;
            };
            
            active_plans
        }
        
        /// Get plans by token address
        fn get_plans_by_token(self: @ContractState, token: ContractAddress) -> Array<u256> {
            let mut plans = ArrayTrait::new();
            let count: u32 = self.plans_by_token.read(token).try_into().unwrap();
            
            let mut i = 0;
            loop {
                if i >= count {
                    break;
                }
                let plan_id = self.plans_by_token_data.read((token, i));
                plans.append(plan_id);
                i += 1;
            };
            
            plans
        }
        
        /// Set developer fee rate (only owner)
        fn set_fee_rate(ref self: ContractState, fee_rate: u256) {
            self.ownable.assert_only_owner();
            assert(fee_rate <= 1000, 'Fee rate too high'); // Max 10%
            
            let old_rate = self.developer_fee_rate.read();
            self.developer_fee_rate.write(fee_rate);
            
            self.emit(DeveloperFeeRateUpdated {
                old_rate,
                new_rate: fee_rate,
                updated_by: get_caller_address(),
                updated_at: get_block_timestamp(),
            });
        }
        
        /// Set developer fee recipient (only owner)
        fn set_fee_recipient(ref self: ContractState, recipient: ContractAddress) {
            self.ownable.assert_only_owner();
            assert(!recipient.is_zero(), 'Invalid recipient');
            
            let old_recipient = self.developer_fee_recipient.read();
            self.developer_fee_recipient.write(recipient);
            
            self.emit(DeveloperFeeRecipientUpdated {
                old_recipient,
                new_recipient: recipient,
                updated_by: get_caller_address(),
                updated_at: get_block_timestamp(),
            });
        }
        
        /// Get developer fee rate
        fn get_fee_rate(self: @ContractState) -> u256 {
            self.developer_fee_rate.read()
        }
        
        /// Get developer fee recipient
        fn get_fee_recipient(self: @ContractState) -> ContractAddress {
            self.developer_fee_recipient.read()
        }
        
        /// Increment subscriber count for a plan (called by subscription contracts)
        fn increment_subscribers(ref self: ContractState, plan_id: u256) {
            // Verify that the caller is the subscription contract for this plan
            let mut plan = self.plans.read(plan_id);
            assert(!plan.id.is_zero(), 'Plan does not exist');
            assert(get_caller_address() == plan.contract_address, 'Only subscription contract');
            
            // Increment the subscriber count
            plan.total_subscribers += 1;
            self.plans.write(plan_id, plan);
        }
        
        /// Decrement subscriber count for a plan (called by subscription contracts)
        fn decrement_subscribers(ref self: ContractState, plan_id: u256) {
            // Verify that the caller is the subscription contract for this plan
            let mut plan = self.plans.read(plan_id);
            assert(!plan.id.is_zero(), 'Plan does not exist');
            assert(get_caller_address() == plan.contract_address, 'Only subscription contract');
            
            // Decrement the subscriber count (prevent underflow)
            if plan.total_subscribers > 0 {
                plan.total_subscribers -= 1;
            }
            self.plans.write(plan_id, plan);
        }
        
        /// Update plan revenue (called by subscription contracts)
        fn update_plan_revenue(ref self: ContractState, plan_id: u256, total_payment: u256, creator_payment: u256, platform_payment: u256) {
            // Verify that the caller is the subscription contract for this plan
            let mut plan = self.plans.read(plan_id);
            assert(!plan.id.is_zero(), 'Plan does not exist');
            assert(get_caller_address() == plan.contract_address, 'Only subscription contract');
            
            // Store creator address before modifying plan
            let creator_address = plan.creator;
            
            // Update plan revenue
            plan.total_revenue += total_payment;
            plan.creator_revenue += creator_payment;
            plan.platform_revenue += platform_payment;
            let current_timestamp = get_block_timestamp();
            plan.last_payment_time = current_timestamp;
            
            // Store updated plan
            self.plans.write(plan_id, plan);
            
            // Update global platform revenue
            let current_platform_revenue = self.total_platform_revenue.read();
            self.total_platform_revenue.write(current_platform_revenue + platform_payment);
            
            // Update creator total revenue
            let current_creator_revenue = self.creator_revenues.read(creator_address);
            self.creator_revenues.write(creator_address, current_creator_revenue + creator_payment);
            
            // Read updated plan for event emission
            let updated_plan = self.plans.read(plan_id);
            
            // Emit events
            self.emit(RevenueUpdated {
                plan_id,
                total_revenue: updated_plan.total_revenue,
                creator_revenue: updated_plan.creator_revenue,
                platform_revenue: updated_plan.platform_revenue,
                updated_at: updated_plan.last_payment_time,
            });
        }
        
        /// Get plan revenue information
        fn get_plan_revenue(self: @ContractState, plan_id: u256) -> (u256, u256, u256, u64) {
            let plan = self.plans.read(plan_id);
            assert(!plan.id.is_zero(), 'Plan does not exist');
            (plan.total_revenue, plan.creator_revenue, plan.platform_revenue, plan.last_payment_time)
        }
        
        /// Get total platform revenue across all plans
        fn get_total_platform_revenue(self: @ContractState) -> u256 {
            self.total_platform_revenue.read()
        }
        
        /// Get total revenue for a specific creator across all their plans
        fn get_creator_total_revenue(self: @ContractState, creator: ContractAddress) -> u256 {
            self.creator_revenues.read(creator)
        }
        
        /// Add user subscription to index (called by subscription contracts)
        fn add_user_subscription(ref self: ContractState, user: ContractAddress, plan_id: u256) {
            // Verify that the caller is the subscription contract for this plan
            let plan = self.plans.read(plan_id);
            assert(!plan.id.is_zero(), 'Plan does not exist');
            assert(get_caller_address() == plan.contract_address, 'Only subscription contract');
            
            // Check if subscription already exists to prevent duplicates
            let exists = self.user_subscription_exists.read((user, plan_id));
            if exists {
                return; // Already exists, no need to add again
            }
            
            // Get current subscription count for user
            let current_count: u32 = self.user_subscriptions.read(user).try_into().unwrap_or(0);
            
            // Add plan_id to user's subscription list
            self.user_subscriptions_data.write((user, current_count), plan_id);
            
            // Update subscription count
            self.user_subscriptions.write(user, (current_count + 1).into());
            
            // Mark subscription as existing
            self.user_subscription_exists.write((user, plan_id), true);
            
            // Emit event
            self.emit(UserSubscriptionAdded {
                user,
                plan_id,
                added_at: get_block_timestamp(),
            });
        }
        
        /// Remove user subscription from index (called by subscription contracts)
        fn remove_user_subscription(ref self: ContractState, user: ContractAddress, plan_id: u256) {
            // Verify that the caller is the subscription contract for this plan
            let plan = self.plans.read(plan_id);
            assert(!plan.id.is_zero(), 'Plan does not exist');
            assert(get_caller_address() == plan.contract_address, 'Only subscription contract');
            
            // Check if subscription exists
            let exists = self.user_subscription_exists.read((user, plan_id));
            if !exists {
                return; // Doesn't exist, nothing to remove
            }
            
            // Get current subscription count for user
            let current_count: u32 = self.user_subscriptions.read(user).try_into().unwrap_or(0);
            
            if current_count == 0 {
                return; // No subscriptions to remove
            }
            
            // Find and remove the plan_id from user's subscription list
            let mut found_index: Option<u32> = Option::None;
            let mut i: u32 = 0;
            
            // Find the index of the plan_id to remove
            while i < current_count {
                let stored_plan_id = self.user_subscriptions_data.read((user, i));
                if stored_plan_id == plan_id {
                    found_index = Option::Some(i);
                    break;
                }
                i += 1;
            };
            
            // If found, remove by swapping with last element and decrementing count
            if let Option::Some(index) = found_index {
                let last_index = current_count - 1;
                
                // If not the last element, swap with last element
                if index != last_index {
                    let last_plan_id = self.user_subscriptions_data.read((user, last_index));
                    self.user_subscriptions_data.write((user, index), last_plan_id);
                }
                
                // Clear the last element and update count
                self.user_subscriptions_data.write((user, last_index), 0);
                self.user_subscriptions.write(user, last_index.into());
                
                // Mark subscription as not existing
                self.user_subscription_exists.write((user, plan_id), false);
                
                // Emit event
                self.emit(UserSubscriptionRemoved {
                    user,
                    plan_id,
                    removed_at: get_block_timestamp(),
                });
            }
        }
        
        /// Get all plan IDs that a user has subscribed to
        fn get_user_subscriptions(self: @ContractState, user: ContractAddress) -> Array<u256> {
            let count: u32 = self.user_subscriptions.read(user).try_into().unwrap_or(0);
            let mut subscriptions = ArrayTrait::new();
            
            let mut i: u32 = 0;
            while i < count {
                let plan_id = self.user_subscriptions_data.read((user, i));
                if plan_id != 0 { // Only add non-zero plan IDs
                    subscriptions.append(plan_id);
                }
                i += 1;
            };
            
            subscriptions
        }
        
        /// Get the number of subscriptions a user has
        fn get_user_subscription_count(self: @ContractState, user: ContractAddress) -> u32 {
            self.user_subscriptions.read(user).try_into().unwrap_or(0)
        }
    }
}